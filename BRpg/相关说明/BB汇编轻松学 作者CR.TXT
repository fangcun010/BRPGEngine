《BB汇编轻松学!》---------------------------｜作者：cr(cr1992)       ｜｜QQ：609079226          ｜｜Space：cr1992.ys168.com｜｜时为BBK游盟论坛超版    ｜     ｜KFXSMXD.5d6d.com       ｜｜BBKBBS-布丁            ｜---------------------------序言为什么要学习汇编语言?

  编者注:该文章非编者原创,是台湾宏基公司 "仓颉输入法" 的作者朱邦复所写.

一、结构基础

    物质文明之有今天的成就，是因为人类掌握了物质的基本结构。物质的种类无穷，
但是却都由基本元素交互组成，只要根据一定的法则，就能得到一定的结果。
    计算机技术虽然日新月异，应用软件的变化也无止无尽，而其基本因子却非常有限。
各种微处理器的汇编语言，正是计算机软件的基础结构，任何要通过软件以完成的动作，
都是经由汇编语言的指令群，逐步执行的。
    因为计算机结构复杂，各种任务分工极精，即使是一位资深的高级程序员，终其生
也不过局限在若干固定的程序中钻研，很难以宏观的立场认知全貌。再加上市 ⌒枨蟮?
压力，局外人莫名其奥妙，局中人又忙得不可开交，所以还没有任何人能作出全盘的评
估。
    汇编语言首先成为被误解的牺牲者，包括应用它的系统工程师在内，都一致认为它
「难学难用」，（中文也是一种组合形式的应用，其所组合者是人的概念。无独有偶，
人们在不求甚解之余，都视之为畏途。）事实上大谬不然，现在是科学挂帅，而科学的
精义就在于系统的分类和应用。问题是我们能不能归纳出一些学习、应用的法则，将组
合的过程化繁为简，以符合各种应用范畴。

二、个人体验

    我个人对此感受极为深切，我原是个十足的外行，1978年第一次接触计算机，曾以
不到两周的时间，就学会计算机操作，并应用「培基语言」设计完成"仓颉输入"
程序。当时我认为培基语言易学易用，是计算机上最好的工具。
    后来，我开始用培基语言设计"仓颉向量组字"程序，每秒可生成两个字，当
时与我合作的宏公司建议我采用汇编语言，他们说组字程序速度要快，培基语言不能
胜任。如改用汇编语言，效率可提高十倍，由此开始了我与汇编语言的不解之缘。1979
年９月我们正式推出了由国人自行设计、具有完整的计算机功能、可运用数万中文字的
"天龙中文计算机"。
    宏公司动用了三位资深工程师，采用 Z80 MCZ系统，以六个月的时间完成了向量
组字及系统程序，记忆空间占60KB，处理速度每秒约组成30字。
    这是我首次发现到汇编语言的威力，深究之下，才理解到计算机的全部工作原理。
简单说来，汇编语言就是组合计算机所有功能的控制指令，利用它，就可以直接控制计
算机。
    其它高级语言，只是让人省事，用一些格式化的手续，把人的想法化为过程的指令，
这种情形就相当于为了迁就开车的人，建了密如蛛网的高速公路。本来走路只要几分钟
就可到达的地方，以车代步的结果，反而需要耗费半个小时。
    1980年，我决定自己动手，又重新设计了一套字数较多，字形较美观的组字程序。
只用了三个月的时间，结果不仅记忆空间缩小了三分之一，速度也快了十倍，达到每秒
 300字。这个产品，就是1苹果机上用的「汉卡」。
    1983年，再经分析，我发现以往写的程序很不精简，技术也不成熟。我坚信中文字
形在计算机上的应用，将是中国文化存亡兴衰的根本因素，不仅值得投注自己的时间及
精力，且也有此必要。所以我又掉了一切，重头设计，加入更多的变化参数，并根据
人的辨识原理，设计成第三代至第五代等多种字形产生器。每一代之间，速度都明显地
提高，功能也不断加强。在这样一再重复的摸索中，尝试了各种可行的途径，充份认识
了汇编语言的特性及长处。
    由于汇编语言灵活无比的特性，我发现它就如同画家的画笔一般，只为了牟利，可
以用它画成各种廉价速成的商品；一旦投入自己的理想与心智，画笔就不再只是一枝笔，
而成为人心与外界的界面，画出的作品立时升华成为艺术，进入一个更高的境界！
    1985年，我再次重新设计规划，采用人的智能原则，把人写字、认字的观念化为数
据结构，程序只是用来阐释数据、控制计算机的界面。该字库的字形可做到无级次放大
缩小，字体、字型皆能任意变化 (每字可以产生数亿种变形) 。而且除了现今各种字典
已收的六万余字外，还可以组成完全符合中文规则的新字六百万个，足敷未来新时代新
观念的发挥应用。
    不仅如此，组字速度又提高了，每秒可以组成 30*30的字形两千个！当然现在用的
是15MHZ 80286 ，比以往的4.75 MHZ的Z80 已经快了近六倍。但是，改良后的新程序，
其功能的增加，处理过程的繁杂性已远非当年可比。
    这些成果，用了很多特殊的数据结构技巧，不可能经由高级语言来完成。既然用汇
编语言所制作的程序能一再大幅度地改进，这就说明了汇编语言的弹性极大，效率相去
千里。如不痛下苦功钻研，程序写完，能执行就算了事，又怎能领悟其中奥妙？
    所以，我并不认为汇编语言只是一种程序语言而已，它是一种创造艺术品的工具，
它能赋与无知无觉的电子机器一种「生命」，由无知进而有知，由有知而生智能。通过
对汇编语言的研究探索，我整理出一些规律，写成这本书，以便于理解及应用。但是，
要真正将汇编语言发展成为艺术，尚有待青年朋友们继续努力，在这个信息时代，开拓
出一片崭新的天地。
    无意义的音符能编成美妙的音乐，无规律的色彩可幻化为缤纷的世界，为什么计算
机的机器指令，不能架构出信息的理性天地？
    这就是艺术，作为艺术家，就必须奉献出自己的心血，以真、善、美为最高境界。
    要达到这种目的，就要认真的作好准备动作，再一步一步地追求下去。

三、利人与利己

    任何一种商业产品，当然是以利益为先，利己后而利人。如果是艺术品创造，则刚
刚相反，唯有能忽视己利，沥血泣心地探索，虔诚狂热地奉献，才会迸发出人性的光辉，
创造不朽的杰作。
    艺术家之伟大，在于此，人性之可贵，在于此。
    对组合程序语言，有人视为商品，将写作技巧当作专利，轻不示人。相信这也是迄
今尚无一本象样的参考书籍之根本原因，我买了不少这类书，但书中除了指令介绍以及
编程、侦错的手续外，完全没有技巧的说明，好象懂得指令就可以把程序写好一般。当
我自己下了不少功夫，得到了一些心得，再回过头来看那些参考书，才发现连作者本人
所举的例子，都是平铺直叙，毫无技巧可言。
    （更正，在序言中我曾提到有本最近出版的"禅－汇编语言"，是唯一的例外，
希望读者不要错过。）
    多年来，我一直想写本有关汇编语言写作技巧的书，可惜都得不到机会。这次，为
了实现「整合系统」革命性的计划，所有招收的工程师，一概从头训练。由于没有可用
的教材，只好自己动手，于是初步有了讲义，再经修改，便成此书。
    我认为，既然汇编语言是种艺术，我们不仅不应该藏私自珍，而且要相互探讨，交
流切磋，以期发扬光大。
    不过，技术本身与利用该技术所创造的产品却不能混为一谈，产品是借以谋生的工
具，能够生存，大家才有研究发展的机会，也才能把成果贡献给社会。如果国人不尊重
别人的产品权利，只是互相抄袭盗用，或能受惠于一时，但影响所及，人人贪图现成，
不事发展，则观念停顿，技术落伍，其后果不堪设想。



前言(作者的话)  其实,我写这本书是怀着郁闷的心情写的,接二连三的倒霉事真打击人啊!  首先是论坛,先是花n多时间申请版主,满怀信心的等结果,结果一句“暂不招收”把我从天上打下来.再是在我花N多时间的帖子中,有人骂我lj...他欺负我不懂拼音,看不懂意思啊!别人辛辛苦苦写文章他竟骂“lj”,我不想说太多,ID也难得说,虽然可能是他无心的一句话,但会让那些文章作者很不舒服.  再次,我的QQ被一个杀千刀万刀也不足惜的人渣盗走,无情的划去了我40多元Q币!!我去看时,只剩0.5Q币...心碎啊!!!40多RMB!!那人渣太不厚道!全拿走了!!更郁闷的是腾讯都不让人有取回钱的可能!T＿T...  是不是很倒霉?俗话说郁闷成疾,我可不能这样!化悲痛为力量,写篇超长教程给各位布丁吧～～  本文是我研究汇编多天后起笔的,参看了不少文章和写作格式.原创作品!写这么长,版主不给精华就不像话了哦～  本文版权归全体布丁所有～～   All Right Reserved.Copyright (C) All Puddings.｛正文｝……关于汇编……一、什么是汇编
    汇编是一种电脑语言，可直接操纵硬件设备。BB汇编采用VMBASIC汇编语法。

二、汇编在BB中的应用
    汇编不适合编写程序（因为代码冗长错误率高等），主要应用:
    1.优化程序
    2.破解程序
    3.编写系统工具

三、关于学习汇编
    常久以来，大家可能一直对汇编存在一种畏惧心理。大家只要看到汇编，就会想：啊！汇编～高手啊！     汇编其实非常简单易懂，汇编语言十分简洁容易理解。我们对其根本不用有畏惧心理！很多人看教程不懂是因为教程不对！6502汇编和BB的汇编是不同的！这篇教程才是针对BB汇编写的！只要用心看，你也可以学会！

……学在汇编前……

//进制转换

1. 16进制

     十六进制数的每一位有16个不同的数码,分别为 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F
     分别表示 10进制中的 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15

2. 2进制

     在2进制中,每一位仅有 0 和 1 两个可能的数码,所以基数为 2.低位和相邻高位的关系是
"逢2进1",所以称为2进制.

3. 2进制转化为10进制
     例如 把 1101 转为 10进制 = 1 * 2 * 2 * 2 + 1 * 2 * 2 + 0 * 2 + 1 = 8 + 4 + 1 = 13
    可见,转化很简单,只是基数是 2

4. 10进制转化为2进制
      例如 将 173 转化为 2 进制

      173 /2 = 86 余数 = 1

      86 /2 = 43 余数 = 0

      43 /2 = 21 余数 = 1

      21 /2 = 10 余数 = 1

      10 /2 = 5  余数 = 0

      5 /2 = 2   余数 = 1

      2 /2 =1    余数 = 0

      1 /2 =0    余数 = 1

　   所以结果为 1011 0101

　 5. 16进制转化为 10进制
     例如  A2  转化为10进制 = 10 * 16 + 2 = 162
     BD 转化为10进制 =  11 * 16 + 13 = 189

6. 10进制转化为16进制
     例如  162 转化为 16进制 

     162 /16 = 10,余数 = 2
     所以结果为 A2第一章 BB汇编介绍引子  BBK论坛编程区高手如云，有的精通BB，有的精通CVM，可说到BB汇编，敢说精通的就不多了吧？  BB汇编，简单易懂，可惜目前论坛对之比较熟悉的只有Bhoppi，天狼星，Rxin等人，知道一点的如八杯酒等，这个数量实在太少！  BB汇编，由于将直接操作硬件，潜力将很大！BB汇编，精彩无限！
一、BB汇编的原理
    先来说下天狼星研究的BIN文件原理:BB的执行程序从.BIN中读取机器码，按机器码进行逐步执行，进行指定的操作。
    事实上，BB执行程序是一个模拟机，模拟一个具有8寄存器的CPU执行BIN文件，EXE根据BIN中的指令进行跳转，中断等各种操作。
    PS:当然这样执行是极慢的(要不停读取BIN文件，想想用复制工具拷文件的速度)，为什么CVM的那么快？CVM执行文件方式被优化了！所以说，BB想提速，就要破解EXE，再优化执行方式。汗～几乎就是自己开发新BB，大家还是不用想了～真能破解BBK就会有新虚拟机了。二、BB编译器原理    BB编译器为什么可以编译汇编？    先说一下编译过程吧！先是用BBASIC编译代码，生成obj文件，再用BLINK连接为bin文件。BB那个编译程式是用Microsoft VC写的，编译时会调用BBASIC和BLINK文件。    obj文件到底是什么？直接用PC记事本打开看吧！里面是不是有一大堆乱七八糟的东西？那就是BB汇编！其实所谓的编译就是将代码转为纯汇编代码，很复杂是不是？所以不适合用纯汇编写大程序，会把眼睛看花的.obj文件就是汇编，BLINK能连接成功，所以我们自己嵌入汇编是可编译的，若是纯汇编的小程序直接保存为OBJ文件连接，不需用vasm()内嵌。    如何单独调用BBASIC编译，BLINK连接呢？    这其实也是个很简单的问题，BB的开发包中自带“Samples”文件夹。这个文件夹里有很多.BAS源文件和.BAT批处理文件。打开相应的bat就会编译并调用模拟器。所以。我们可通过批处理文件轻松调用。具体写法我不想多言，大家自己参看批处理文件并模仿写。如果这都不会，你就不要再往下看了，因为你的理解能力太差。三、寄存器
    BB的寄存器是虚拟机模拟出的，共8个(其操作在后面介绍)，你暂不要管什么是寄存器，先看:
    指令寻址寄存器 rp
    通用寄存器     r0,r1,r2,r3
    堆栈           rb
    辅助堆栈       rs
    标志寄存器     rf
      大于  AE
      小于  BE
      零  Z
      非零  NZ

四、操作语句
    语句为操作数据，程序运行方向等的汇编码(简单介绍，具体应用后文详细介绍)。
    无条件跳转  JMP
    调用        CALL
    条件跳转    JPC
    数据装载    LD
    数据比较    CMP
    数据运算    CAL
    输入        IN
    调用中断    OUT
    空指令      NOOP
    退出        EXIT
    压栈        PUSH
    弹栈        POP
    返回        RET
    定义量      DATA

五、数据类型
    双字节      dword
    整数        int
    单精度浮点  float
    单字节      word
    字符串      char

六、数据前缀    BB汇编中，有几种数据前缀，在定义变量时加上，代表数据类型。定义以后说，先说前缀。    VINT_   整型量    VFLO_   浮点量    VSTR_   字符串量七、汇编中的符号    同BB一样，BB汇编涉及的符号都必须是半角符号。“[]”不能在小机直接输入。用到时留空，用编辑器改，ASCII码为91和93。
第二章 汇编入门
一、数据操作与处理注：本文书写顺序与天狼星原创作品近似，但将会更详细，更容量理解。    1.LD
    LD语句为数据装载语句，例如

    LD int r3,2 ;将数2送入寄存器r3
    LD int [VINT_STATIC_INT],4   ;将立即数4送入整型变量STATIC_INT

    ;为注释号，等同于BBASIC的"号
    VINT_为量前缀，前面提过。
    []为变量指针(相当于C语言的指针运算符*)，例如
    LD int r3,a  ;将a的地址送入r3
    LD int r3,[a]  ;将地址a下的值送入r3
    两种的差别显而易见，这也是要特别注意的。大家只要寄得有括号操作的是数值，无括号，操作的是地址。    给个建议：由于编译时r3会被编译为大写，PC手动改才可行，小机就直接完完。想在小机上编译内嵌汇编而不出问题，有两种方法：    1.嵌入汇编到“STDLIB.lib”，这样的话，用到的函数从这里取，不用担心调用寄存器出错。自己想办法正确嵌入吧！    2.用BB共享变量取代    这么做虽然麻烦写，但可用更多的汇编了，函数头来一个：    dim shared ***    可参看BB库文件。共享变量速度比寄存器慢，因为寄存器是最快的，需要用寄存器的尽量用共享变量替换，把数据装入就行。  
 2.DATA
    定义一个量(可以是变量，常量)，例如

    DATA a dword 0  ;定义32bit变量a，初值为0，a为指针
    LD int [a],4  ;将立即数4送入变量a
    EXIT  ;程序结束
    a代表是地址,0是地址下的值
    上面1.LD中所讲代码均不可执行，因为未定义量，无退出
    又如
    字符串定义
    DATA CS_CSTRING_3 char "步步高",0   ;定义字符串常量CS_CSTRING_3，值为“步步高”。
    DATA CSTRING_3 dword 0    ;定义双字节值CSTRING_3，初值为0
    LD [CSTRING_3],CS_CSTRING_3 
    EXIT

    上面代码其实就是BBASIC的字符串初始化汇编码。

  3.PUSH 和 POP
    PUSH是数据存入堆栈，POP是取出，例如

    LD int r3,2
    PUSH 5   ;5进栈，栈指针加1
    POP r2   ;数据出栈，栈指针减1

    PUSH操作往往用作调用中断、函数、存放局部变量等，BB堆栈为1KB，存在rb里。函数调用数值就会存入！数据太多会产生上溢出，也就是爆栈。那就完完了～～

  4.IN 和 OUT
    输入／输出指令，例如

    IN r3,15  ;调用tick-tock(计数器),存入寄存器r3
    OUT 3,r3  ;调用屏幕中断，以数字形式显示r3(实质是tick-tock值)
    LD int r2,65
    OUT 4,r2  ;以ASCII的形式显示r2(屏幕显示A，相当于BB的“print Chr$(65)”)
    OUT 4,10  ;10的ASCII就是换行(回车符)，输出一个换行，就是“PRINT”指令(类似C语言的“printf("\n")”)
    IN,OUT还有很多种用法，可参看“stdlib.lib”里的汇编函数。如，OUT 39,0，这是WAITKEY()，返回键值在r3里，故可用这个原理来写键值获取器，非常小巧。
    有些IN和OUT要调用堆栈或寄存器中的数据，例如

    DATA CS_A char "cronline",0
    DATA A dword 0
    LD [A],CS_A  ;字符串装载处理不加数据类型
    PUSH [A]
    POP r2
    IN r3,2
    IN r2,5
    PUSH r3
    POP r3
    OUT 2,r3
    IN r3,8
    EXIT

    以上代码可以直接BLink，屏幕显示“cronline”(等效于“print  "cronline"”)。
    CS_A前面那个CS不是反恐，是字符串初始化量的前缀。

  5.逻辑命令
    JMP无条件跳转，但要先设标志，类似GoTo

    ;无限显示运行时间，单位秒，注意这是一个死循环。
    IN r2,15  ;获取初始时间
    Label1:  ;标志
    IN r3,15  ;获取当前时间，可参看库文件gettick()函数
    CAL int SUB r3,r2
    CAL int DIV r3,1000
    OUT 35,0   ;屏幕中断，清屏
    OUT 3,r3
    JMP Label1   ;跳回Label1，下一循环开始
    EXIT

    CAL计算命令，共5种

    CAL int ADD r3,1  ;r3加1
    CAL int SUB r3,1  ;减1
    CAL int MUL r3,1  ;乘1
    CAL int DIV r3,1  ;除1
    CAL int MOD r3,1  ;除1取余

    CMP比较命令，例如

    CMP int r2,r3  ;比较r2和r3，自动改变标识位
    r2等于r3,Z置1,否则置0
    r2大于r3,AE置1,否则置0
    r2小于r3,BE置1,否则置0

    JPC条件跳转，检测指定标识位，为1跳转，例如构造循环

    ;计算从1加到100的和
    LD int r0,1   ;r0作为循环控制变量
    LD int r3,1   ;r3存储答案
    Label1:
    CAL int ADD r3,r0
    CAL int ADD r0,1
    CMP int r0,100   ;比较r0与100大小
    JPC NZ Label1   ;如r0不等于100跳到循环头，否则往下运行，记好这个NZ
    OUT 3,r3  ;结果输出
    EXIT

  6.其他命令
    NOOP空指令，一般无用
    EXIT退出，作用是显示“程序运行结束，按任意键退出！”，并结束运行
    CALL调用，常用于子函数
    RET返回CALL，执行CALL的下一语句，常用于子函数返回

注意:
    一句语句最多只能操作2个数据，类似于
    LD int r2,(CAL int r3,1)
    这样的写法是绝对错误的。



第三章 代码中的汇编1.BB汇编结构    BB的汇编可以内嵌，也可只接写纯汇编，然后BLINK。    前面已经说过BB的编译原理，这就不多说了。示范一个简单的程序，看看纯汇编的样子吧！    Dim a    a=3    print a    看看obj文件吧!CALL LABEL0 ; For initialization
;================MAIN PROG==================;<Init data ptr>LD dword r2,CD_INITDATAIN r2,22;</Init data ptr>;<Epression>; Flush stack: 1  [1]PUSH 3POP r3;</Epression>LD int r0,VINT_ALD int [r0],r3;<Epression>; Flush stack: 16  [1]PUSH [VINT_A]POP r3;</Epression>OUT 3,r3OUT 4,10EXIT    看起来是不是很复杂？这是BB编译的汇编结构。我们自己写，是不需这么复杂的！看：    DATA A INT 0    LD INT [A],3    OUT 3,A    就是这么简单！我们自己写就用这种写法！内嵌也可用这个！    小窍门：小机上获取obj文件!    一般情况下，在小机上编译成功，才有完整的obj。可是既然可编译，小机就会把它连接生成bin，再删掉。想看怎么办？在程序末尾，加上这一句即可：    out 3,r3    注意用vasm语句内嵌啊！这其实是显示r3寄存器的东西，完全正确的语句。可编译成功r3变R3，连接不了，得obj文件，在obj中找这一句，删除即得obj代码文件。2.VASM内嵌语句    这个语句的功能是向BB语句中嵌入汇编语句，只有用这个，BB编译器才能识别汇编。格式：    VASM("汇编语句")    我们可以用汇编写函数，STDLIB.LIB文件就是一个很好的例子。学完本文你就能读懂此文件了。结合内部函数写法，你可轻松实现一些功能，如显示小写等。    因此，使用VASM语句内嵌汇编可以使程序优化，获得更小的文件和更高的效率。很明显的例子，GETTICK函数，我们可直接嵌入它的一句汇编函数(STDLIB.lib)，便可用此功能！速度加快很多！因为BB汇编码会调用整个GETTICK函数，降低了速度，可是，我们一句：    VASM("in [a],15")    就是直接调用核心！速度可想而知。此函数直接让变量a计数。    BB编译的优化就是这原理。3.函数中的数字调用    看到这里了，相信大家差不多可看懂BB的库文件了吧？不过大家可能还看不出函数的中的字符串，数字是如何调用的吧？我来解释下。为了方便输入，注示用'符号代替。    以LEFT$函数为例：    FUNCTION LEFT$(X$,N)
 DIM SHARED STATIC_STR$ '定义共享变量

 STATIC_STR$ = X$ '调用
 VASM("LD int r3,[VSTR_STATIC_STR]") '将数据送入r3
 VASM("LD int r0,rb") '为何调用rb?这是堆栈寄存器!程序中涉及的数据都在其中!再看如何一个个调用. 
 VASM("CAL int ADD r0,12") 'r0地址加12.知道了吧?加12调用第二个,如用三个就加16.以此类推.
 VASM("LD int r2,[r0]") '送r0的数据,也就是函数中N到r2寄存.
 VASM("IN r1,35") '调用硬件处理
 LEFT$ = STATIC_STR$ '获得数据
END FUNCTION    因为这个函数中有两种调用数据方式，所以用这个为例。方法注释中说明了，可用共享变量取，可从堆栈取。    说得这么详细，该可以看懂吧！为了巩固知识，建议多看看“stdlib.lib”。    PS：已写了好长了啊，不过写的和天狼星的有点近似啊～不过原创的还是很多了。之所以参看别人的文章，是怕自己写的太乱，所以用和天狼星的教程相同的顺序来写～好好看哦～我对我这篇文章的优秀程度没怀疑：）第四章 纯汇编程序
一、程序结构
    一个完整的程序代码包括:
    1.量说明(变量,常量)
    2.数据输入
    3.数据处理
    4.数据输出
    纯汇编往往用于编写高效率的简单程序和系统工具。(完全是天狼星说的,没办法,就是这样,我不能乱说吧～)

二、BB代码和汇编码的互相转化
    好好看,有我原创的.
代码             汇编(优化)
cls              OUT 35,0
print a          OUT 3,[VINT_A]
                 OUT 4,10
print asc$("65") OUT 4,65
                 OUT 4,10
print            OUT 4,10
a=GetTick()      IN [VINT_A],15
a=a+1            CAL int ADD [VINT_A],1
001              LABEL4:
GoTo 001         JMP LABEL4
Dim a            DATA VINT_A dword 0
print a$         PUSH [VSTR_A]
                 POP r2
                 IN r3,2
                 IN r2,5
                 PUSH r3
                 POP r3
                 OUT 2,r3
                 IN r3,8
waitkey()        OUT 39,0
a=Peek(Addr)     LD int r3,[VINT_ADDR]
                 IN r3,23
                 LD int [VINT_A],r3
open a$ for binary as #2
                 PUSH [VSTR_A]
                 POP r2
                 IN r3,2
                 IN r2,5
                 LD int r1,1
                 LD int r2,2
                 OUT 48,0
                 IN r3,8
Put #2,a         LD int r0,VINT_A
                 LD int r1,2
                 LD int r2,2147483647
                 LD int r3,[r0]
                 OUT 51,16

    以上只是一部分常用代码的汇编码，其他的可以在StdLib.lib中找到。
    这里不推荐大家用纯汇编写大程序，但是我们可以用汇编写一些小巧实用程序,给两个例子(效率都应该很高):
  

1.显小写
    这只适合少量使用！内嵌既可。
    OUT 4,99
    out 4,114
    这两句编译屏幕上显cr，4后面数字是ASCII码，13，10为换行

2.快速获键值    
    其实这很简单，利用waitkey后会在寄存器r3写入返回值，也就是键值。我发了这程序，有兴趣在坛子找，这里用最简化的程序    label:    '标签    out 35,0  '清屏    out 39,0  'WAITKEY,返回值在r3    out 4,r3  '显按键    out 3,r3  '显键值     out 39,0  '等待,判断跳出    CMP INT r3,27 '判断按没按退出    JPC NZ LABEL  '否,循环    exit  '是,退出        看看，又小有简洁，效率高～3.秒表(BY 天狼星)
    DATA CS_CSTRING char "Any Key to Start,ESC to exit",0
    DATA CSTRING_HINT dword 0
    LD [CSTRING_HINT],CS_CSTRING
    PUSH [CSTRING_HINT]
    POP r2
    IN r3,2
    IN r2,5
    PUSH r3
    POP r3
    OUT 2,r3
    IN r3,8
    OUT 4,10
    OUT 39,0
    OUT 39,0
    IN r3,15
    PUSH r3
    LABEL1:
    OUT 35,0
    LD int r1,23
    LD int r0,[r1]
    CAL int ADD r0,12
    LD int r3,[r0]
    OUT 34,0
    LD int r2,r3
    CMP int r2,1
    JPC Z LABEL2:
    IN r2,15
    POP r0
    CAL int SUB r2,r0
    LD int r3,r2
    CAL int DIV r2,1000
    OUT 3,r2
    OUT 4,58
    CAL int MOD r3,100
    OUT 3,r3
    JMP LABEL1:
    LABEL2:
    EXIT
    看不懂无事，用到时直接用

第五章 汇编的应用
  汇编两大方面应用:
  一、程序优化
    对低效率程序优化，使之提高效率，甚至使用纯汇编编写，使变量保持在寄存器级别，可提速3～5倍。
    汇编效率高，在于其直接调用函数核心。这点很重要，就是因为调用函数核心，免去虚拟机call此函数(看看OBJ文件吧～)，速度自然快。很明显的例子～GETTICK函数。

  二、程序破解
    使用机器码进行反汇编，可以对程序注册码破解，关卡锁定破解等等。(附表附机器码 By天狼星)。


第六章 终极应用
    因程序而异，优化方法则不同，主要看个人经验等。我们可应用于提高效率，加块速度，写小巧实用程序等。

    祝大家写出更多优秀的程序！

                  Presented by cr
                                        2008.5.7
Powerd by Rxin and 天狼心
附表1机器码

各语句机器码
rx表示寄存器
vx表示变量(其实是变量指针)
ax表示地址(整型数)
x表示数字
<>x32 32位数据

寄存器   数据(32位)
rp       00
rf       01
rs       02
rb       03
r0       04
r1       05
r2       06
r3       07

语句               十六进制          十进制
CALL ax            82 ax32           130
JPC Z ax           71 02 ax32        113
JPC BE ax          73 02 ax32
JPC AE ax          75 02 ax32        117
JPC NZ ax          76 02 ax32        118
EXIT               F0                240
RET                90                144
JMP ax             62 ax32           98
LD int rx,rx       14 00 rx32 rx32   20 00
LD int rx,[rx]     14 01 rx32 rx32
LD int rx,x        14 02 rx32 x32
LD int [rx],rx     14 04 rx32 rx32
LD int [rx],[rx]   14 05 rx32 rx32
LD int [rx],x      14 06 rx32 x32
LD int ax,x        14 0A ax32 x32    20 10
OUT rx,rx          50 00 rx32 rx32   80 00
OUT其余同上
IN rx,rx           40 00 rx32 rx32   64 00
IN其余同上
CAL int ADD rx,rx  B4 00 rx32 rx32   180 00
        SUB           10
        MUL           20
        DIV           30
        MOD           40
CAL其余同上
CMP int rx,rx      A4 00 rx32 rx32   164 00
CMP其余同上后记：    终于完本了！惊天大作！耗费我几个晚上的文章！！！！这篇文章是有资格做精华的，不是吗？    在我之前，rxin(逍遥至尊)和天狼星都写了教程。看过他们的，再看我的，你会发现我写的和他们的很相像。    其实，我这篇文章是我融合多篇文章心得而写的，其中参看天狼星文章最多，连顺序都是参看的～～没办法～我怕写乱啦～呵呵～～    感谢您阅读《BB汇编轻松学》，希望对您有所帮助。